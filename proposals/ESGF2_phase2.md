# Programmatic Interfaces and `intake-esgf`

As part of our effort to survey existing community tools, we have identified a growing need for a *programmatic* interface to the Earth System Grid Federation (ESGF) holdings. Many times, a user has a plan for an analysis of ESGF-hosted data, but the simulations that are included in the study depend on what results are found. As not all model centers participate in all experiments, determining which have output appropriate for the analysis involves a conversation with the ESGF system and can be quite intricate to execute through a web interface, especially given its distributed and federated nature. A programmatic interface allows for the results of the query to be presented as objects that a user can write code to hone, allowing for a more systematic and repeatable process for identifying relevant data.

For example, consider the work of a graduate student named Bharat who is analyzing the controls of carbon cycle extremes in future climate scenarios. He needs to find models which have a primary carbon cycle variable (gross primary productivity) as well as control variables (surface air temperature, precipitation, soil moisture, etc.) for a number of experiments and scenarios (historical, ssp585, ssp370, ssp245, ssp126). He needs to know which models and ensemble members have all the variables for all the experiments. Through the interactive web interface, this process takes him weeks of his time. It is not easily repeatable and difficult to communicate to colleagues. Through the programmatic interface, Bharat can write python code that queries the ESGF indices and then parses the results into sets of self-consistent results, discarding the incomplete sets. The script runs in minutes, is self-documenting and easily reproducible.

This kind of programmatic interface is possible in python with the current generation of tools. However, the related packages ([esgf-pyclient](https://github.com/ESGF/esgf-pyclient) and [esg-pull](https://github.com/ESGF/esgf-download)) have somewhat technical interfaces which we find are a barrier for the Earth system scientist. In contrast, we have found the community-developed [intake-esm](https://github.com/intake/intake-esm) to provide a simpler interface to search results which has been designed with the data scientist in mind. Search results are returned as a table, represented in-memory as a [pandas](https://pandas.pydata.org/) DataFrame, which is the widely accepted standard for viewing tabular data in python. The user then narrows their search, or reduces the DataFrame through further python code. Once complete, a single function call will either download data or simply load from a local cache as needed. 

The intake-esm package was developed to provide an interface to a static index of community-developed ESGF holdings. We have written [intake-esgf](https://intake-esgf.readthedocs.io/en/latest/) to leverage their interface but instead dynamically query the ESGF indices. We have written the package to be agnostic towards the backend service. This means that our package can query the established Solr-based indices as well as the Globus-based indices developed in phase 1 of this project. As we designed for multiple search backends, we are poised to easily adapt to the next generations of ESGF technology. We have released intake-esgf in Beta status and have already conducted tutorials and hackathons to engage the community for feedback.

Because the search and download actions are programmable, we can provide automation for painful analysis tasks. For example, Earth system data scientists know that locating the cell measures (`areacella`, `areacello`, `sftlf`) for any given variable can be difficult. They are at times *far* from your current set of search facets. We harvest cell measure information out of the dataset attributes and then perform automatic and successively relaxing searches until we locate the measures and associate them with the dataset automatically. 

In addition to the benefits to the users, intake-esgf's programmatic interface aligns well with other objectives of the ESGF project and activities of the broader community:

1. In addition to the local cache, when a user tries to access data, we check a number of fixed locations where copies of the ESGF holdings are directly available. This means that as we transition to data-proximate computing environments, analysis scripts are completely portable across systems. The same script a user writes to download data on their laptop can be used on a JupyterHub instance (for example https://nimbus.llnl.gov/), and the data will simply be loaded instead of downloaded. 
2. This *modus operandi* also makes supporting small data lakes trivial. A research group can set their local cache directory to a shared location and benefit from the files others have already downloaded. This in turn reduces the stress on the ESGF system by giving users a way to passively share local holdings with no change to the analysis scripts.
3. The search interface has also shown its [use](https://projectpythia.org/esgf-cookbook/notebooks/ex-regrid-plot.html) as it relates to finding data that can be remotely computed on, through web processing services (WPS). Output from intake-esgf can be passed to the [rook](https://rook-wps.readthedocs.io/en/latest/) suite of tools, which remotely handle  subsetting, temporal averaging, and regridding.
4. As the origin of intake-esgf has its roots in intake-esm, we have a mechanism for supporting community efforts in our tooling. While sufficient messaging is needed to indicate to the user that they are accessing resources outside of the ESGF holdings, providing the interface encourages more community engagement and acknowledges their contributions. This in turn gives the ESGF2 project a means to assess the long-term value of fringe efforts like cloud storage and alternate formats in the context and tooling of the original means of providing the data.

